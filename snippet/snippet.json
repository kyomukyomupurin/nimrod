{
    "template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "using ll = long long;",
            "",
            "int main() {",
            "  std::ios_base::sync_with_stdio(false);",
            "  std::cin.tie(nullptr);",
            "  std::cout << std::fixed << std::setprecision(17);",
            "",
            "",
            "  return 0;",
            "}"
        ],
        "timestamp": 1632533161.4730897
    },
    "2d_cumulative": {
        "prefix": "2d_cumulative",
        "body": [
            "template <class T>",
            "class cumulative_2d {",
            " public:",
            "  explicit cumulative_2d(const std::vector<std::vector<T>>& v) {",
            "    x_ = int(v.size());",
            "    y_ = int(v[0].size());",
            "    s_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      for (int j = 0; j < y_; ++j) {",
            "        s_[i][j + 1] = s_[i][j] + v[i][j];",
            "      }",
            "    }",
            "    for (int i = 0; i < y_; ++i) {",
            "      for (int j = 0; j < x_; ++j) {",
            "        s_[j + 1][i + 1] += s_[j][i + 1];",
            "      }",
            "    }",
            "  }",
            "",
            "  T get(int sx, int sy, int gx, int gy) {",
            "    return s_[gx + 1][gy + 1] - s_[gx + 1][sy] - s_[sx][gy + 1] + s_[sx][sy];",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<std::vector<T>> s_;",
            "};"
        ],
        "timestamp": 1632533226.383541
    },
    "compress": {
        "prefix": "compress",
        "body": [
            "template <class T>",
            "class compress {",
            " public:",
            "  explicit compress(const std::vector<T>& v) : d_(v) {",
            "    n_ = int(v.size());",
            "    std::sort(d_.begin(), d_.end());",
            "    d_.erase(std::unique(d_.begin(), d_.end()), d_.end());",
            "  }",
            "",
            "  T find_by_order(int p) const { return d_[p]; }",
            "",
            "  int find_by_value(T x) const {",
            "    return std::distance(d_.begin(), std::lower_bound(d_.begin(), d_.end(), x));",
            "  }",
            "",
            "  int size() const { return n_; }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<T> d_;",
            "};"
        ],
        "timestamp": 1632533224.3445187
    },
    "cumulative": {
        "prefix": "cumulative",
        "body": [
            "template <class T>",
            "class cumulative {",
            " public:",
            "  explicit cumulative(const std::vector<T>& v) {",
            "    s_.resize(v.size() + 1);",
            "    s_[0] = 0;",
            "    std::partial_sum(v.begin(), v.end(), s_.begin() + 1);",
            "    for (int i = 0; i < int(v.size()); ++i) {",
            "      s_[i + 1] = s_[i] + v[i];",
            "    }",
            "  }",
            "",
            "  T get(int l, int r) const { return s_[r + 1] - s_[l]; }",
            "",
            " private:",
            "  std::vector<T> s_;",
            "};"
        ],
        "timestamp": 1632533231.8113227
    },
    "golden_search": {
        "prefix": "golden_search",
        "body": [
            "template <class F>",
            "std::pair<double, double> golden_search(double low, double high, const F& f) {",
            "  const double phi = (1 + std::sqrt(5)) / 2;",
            "  double s1 = (phi * low + high) / (1 + phi);",
            "  double s2 = (low + phi * high) / (1 + phi);",
            "  double y1 = f(s1), y2 = f(s2);",
            "  for (int i = 0; i < 150; ++i) {",
            "    if (y1 > y2) {",
            "      low = s1;",
            "      y1 = y2;",
            "      s1 = s2;",
            "      s2 = (low + phi * high) / (1 + phi);",
            "      y2 = f(s2);",
            "    } else {",
            "      high = s2;",
            "      y2 = y1;",
            "      s2 = s1;",
            "      s1 = (phi * low + high) / (1 + phi);",
            "      y1 = f(s1);",
            "    }",
            "  }",
            "  return {low, y1};",
            "}"
        ],
        "timestamp": 1632533238.36877
    },
    "rle": {
        "prefix": "rle",
        "body": [
            "std::vector<std::pair<char, int>> rle(const std::string& s) {",
            "  int n = s.size();",
            "  std::vector<std::pair<char, int>> v;",
            "  int beg = 0;",
            "  while (beg < n) {",
            "    int ed = beg;",
            "    while (ed + 1 < n && s[beg] == s[ed + 1]) ++ed;",
            "    v.emplace_back(s[beg], ed - beg + 1);",
            "    beg = ed + 1;",
            "  }",
            "  return v;",
            "}",
            "",
            "template <class T>",
            "std::vector<std::pair<T, int>> rle(const std::vector<T>& v) {",
            "  int n = v.size();",
            "  std::vector<std::pair<T, int>> vp;",
            "  int beg = 0;",
            "  while (beg < n) {",
            "    int ed = beg;",
            "    while (ed + 1 < n && v[beg] == v[ed + 1]) ++ed;",
            "    vp.emplace_back(v[beg], ed - beg + 1);",
            "    beg = ed + 1;",
            "  }",
            "  return vp;",
            "}"
        ],
        "timestamp": 1632533254.0419672
    },
    "2d_fenwick": {
        "prefix": "2d_fenwick",
        "body": [
            "template <class T>",
            "class fenwick_2d {",
            " public:",
            "  explicit fenwick_2d(int x, int y) : x_(x), y_(y) {",
            "    d_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "  }",
            "",
            "  explicit fenwick_2d(const std::vector<std::vector<T>>& v) {",
            "    x_ = int(v.size());",
            "    y_ = int(v[0].size());",
            "    d_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      for (int j = 0; j < y_; ++j) {",
            "        add(i, j, v[i][j]);",
            "      }",
            "    }",
            "  }",
            "",
            "  void add(int x, int y, T x) {",
            "    for (int i = x + 1; i < x_ + 1; i += i & -i) {",
            "      for (int j = y + 1; j < y_ + 1; j += j & -j) {",
            "        d_[i][j] += x;",
            "      }",
            "    }",
            "  }",
            "",
            "  T get(int x, int y) const {",
            "    T s = 0;",
            "    for (int i = x + 1; i > 0; i -= i & -i) {",
            "      for (int j = y + 1; j > 0; j -= j & -j) {",
            "        s += d_[i][j];",
            "      }",
            "    }",
            "    return s;",
            "  }",
            "",
            "  T get(int sx, int sy, int gx, int gy) const {",
            "    return get(gx, gy) - get(sx - 1, gy) - get(gx, sy - 1) +",
            "           get(sx - 1, sy - 1);",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<std::vector<T>> d_;",
            "};"
        ],
        "timestamp": 1632533278.2638037
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "class dsu {",
            " public:",
            "  explicit dsu(int n) : n_(n) { p_.assign(n, -1); }",
            "",
            "  int root(int x) { return (p_[x] < 0) ? x : p_[x] = root(p_[x]); }",
            "",
            "  bool same(int x, int y) { return root(x) == root(y); }",
            "",
            "  void merge(int x, int y) {",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (p_[x] > p_[y]) std::swap(x, y);",
            "    p_[x] += p_[y];",
            "    p_[y] = x;",
            "  }",
            "",
            "  int size(int x) { return -p_[root(x)]; }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<int> p_;",
            "};"
        ],
        "timestamp": 1632533286.558231
    },
    "fenwick": {
        "prefix": "fenwick",
        "body": [
            "template <class T>",
            "class fenwick {",
            " public:",
            "  explicit fenwick(int n) : n_(n + 1) { d_.assign(n_, 0); }",
            "",
            "  explicit fenwick(const std::vector<T>& v) {",
            "    n_ = int(v.size()) + 1;",
            "    d_.assign(n_, 0);",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, v[i]);",
            "  }",
            "",
            "  void add(int p, T x) {",
            "    ++p;",
            "    while (p < n_) {",
            "      d_[p] += x;",
            "      p += p & -p;",
            "    }",
            "  }",
            "",
            "  T get(int l, int r) const {",
            "    T s = 0;",
            "    while (l < r) {",
            "      s += d_[r];",
            "      r -= r & -r;",
            "    }",
            "    while (r < l) {",
            "      s -= d_[l];",
            "      l -= l & -l;",
            "    }",
            "    return s;",
            "  }",
            "",
            "  int lower_bound(T x) const {",
            "    if (x <= 0) return 0;",
            "    int p = 0, k = 1;",
            "    while (k < n_ - 1) k <<= 1;",
            "    while (k) {",
            "      if (p + k <= n_ - 1 && d_[p + k] < x) {",
            "        x -= d_[p + k];",
            "        p += k;",
            "      }",
            "      k >>= 1;",
            "    }",
            "    return p;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<T> d_;",
            "};"
        ],
        "timestamp": 1632533295.0472262
    },
    "median_queue": {
        "prefix": "median_queue",
        "body": [
            "template <class T>",
            "class median_queue {",
            " public:",
            "  median_queue() {}",
            "",
            "  void emplace(T x) {",
            "    if (lower_.empty()) {",
            "      lower_.emplace(x);",
            "    } else {",
            "      if (x >= lower_.top()) {",
            "        upper_.emplace(x);",
            "      } else {",
            "        lower_.emplace(x);",
            "      }",
            "      if (upper_.size() > lower_.size()) {",
            "        T t = upper_.top();",
            "        upper_.pop();",
            "        lower_.emplace(t);",
            "      }",
            "      if (lower_.size() == upper_.size() + 2) {",
            "        T t = lower_.top();",
            "        lower_.pop();",
            "        upper_.emplace(t);",
            "      }",
            "    }",
            "  }",
            "",
            "  T median() const {",
            "    if (lower_.size() == upper_.size()) {",
            "      return (lower_.top() + upper_.top()) / 2;",
            "    } else {",
            "      return lower_.top();",
            "    }",
            "  }",
            "",
            " private:",
            "  std::priority_queue<T> lower_;",
            "  std::priority_queue<T, std::vector<T>, std::greater<T>> upper_;",
            "};"
        ],
        "timestamp": 1632533336.5410435
    },
    "raq_fenwick": {
        "prefix": "raq_fenwick",
        "body": [
            "template <class T>",
            "class fenwick_raq {",
            " public:",
            "  explicit fenwick_raq(int n) : n_(n), f1_(fenwick<T>(n)), f2_(fenwick<T>(n)) {}",
            "",
            "  explicit fenwick_raq(const std::vector<T>& v)",
            "      : n_(int(v.size())), f1_(fenwick<T>(v)), f2_(fenwick<T>(v)) {}",
            "",
            "  void add(int l, int r, T x) {",
            "    add(f1_, l, r, x);",
            "    add(f2_, l, r, -x * (l - 1));",
            "    add(f2_, r, n_, x * (r - l));",
            "  }",
            "",
            "  T get(int p) const { return f1_.get(0, p + 1) * p + f2_.get(0, p + 1); }",
            "",
            "  T get(int l, int r) const { return get(r) - get(l - 1); }",
            "",
            " private:",
            "  int n_;",
            "  fenwick<T> f1_;",
            "  fenwick<T> f2_;",
            "",
            "  void add(fenwick<T>& f, int l, int r, T x) {",
            "    f.add(l, x);",
            "    f.add(r, -x);",
            "  }",
            "};"
        ],
        "timestamp": 1632533324.3026536
    },
    "segtree": {
        "prefix": "segtree",
        "body": [
            "template <class M, class F>",
            "class segtree {",
            " public:",
            "  explicit segtree(int n, M ie, F f) : n_(n), ie_(ie), f_(f) {",
            "    sz_ = 1;",
            "    while (sz_ < n_) sz_ <<= 1;",
            "    d_.assign(2 * sz_, ie_);",
            "  }",
            "",
            "  explicit segtree(const std::vector<M>& v, M ie, F f)",
            "      : n_(int(v.size())), ie_(ie), f_(f) {",
            "    sz_ = 1;",
            "    while (sz_ < n_) sz_ <<= 1;",
            "    d_.assign(2 * sz_, ie_);",
            "    for (int i = 0; i < n_; ++i) d_[i + sz_] = v[i];",
            "    for (int i = sz_ - 1; i > 0; --i) d_[i] = f_(d_[2 * i], d_[2 * i + 1]);",
            "  }",
            "",
            "  void update(int p, M x) {",
            "    p += sz_;",
            "    d_[p] = x;",
            "    while (p) {",
            "      p >>= 1;",
            "      d_[p] = f_(d_[2 * p], d_[2 * p + 1]);",
            "    }",
            "  }",
            "",
            "  M get(int l, int r) const {",
            "    M vl = ie_, vr = ie_;",
            "    for (l += sz_, r += sz_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) vl = f_(vl, d_[l++]);",
            "      if (r & 1) vr = f_(d_[--r], vr);",
            "    }",
            "    return f_(vl, vr);",
            "  }",
            "",
            "  M all() const { return d_[1]; }",
            "",
            "  M operator[](int p) const { return d_[p + sz_]; }",
            "",
            " private:",
            "  int n_;",
            "  int sz_;",
            "  M ie_;",
            "  F f_;",
            "  std::vector<M> d_;",
            "};"
        ],
        "timestamp": 1632533317.1009183
    },
    "weighted_dsu": {
        "prefix": "weighted_dsu",
        "body": [
            "class weighted_dsu {",
            " public:",
            "  explicit weighted_dsu(int n) : n_(n) {",
            "    p_.assign(n, -1);",
            "    r_.assign(n, 0);",
            "    w_.assign(n, 0);",
            "  }",
            "",
            "  int root(int x) {",
            "    if (p_[x] == -1) {",
            "      return x;",
            "    } else {",
            "      int r = root(p_[x]);",
            "      w_[x] += w_[p_[x]];",
            "      return p_[x] = r;",
            "    }",
            "  }",
            "",
            "  int weight(int x) {",
            "    root(x);",
            "    return w_[x];",
            "  }",
            "",
            "  bool same(int x, int y) { return root(x) == root(y); }",
            "",
            "  void merge(int x, int y, int w) {",
            "    w += weight(x);",
            "    w -= weight(y);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (r_[x] < r_[y]) {",
            "      std::swap(x, y);",
            "      w = -w;",
            "    }",
            "    if (r_[x] == r_[y]) ++r_[x];",
            "    p_[y] = x;",
            "    w_[y] = w;",
            "  }",
            "",
            "  int diff(int x, int y) { return weight(y) - weight(x); }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<int> p_;",
            "  std::vector<int> r_;",
            "  std::vector<int> w_;",
            "};"
        ],
        "timestamp": 1632533301.054591
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "template <class T>",
            "std::vector<T> bfs(const graph<T>& g, int s) {",
            "  std::vector<T> d(g.size(), -1);",
            "  std::queue<int> q;",
            "  d[s] = 0;",
            "  q.emplace(s);",
            "  while (!q.empty()) {",
            "    int v = q.front();",
            "    q.pop();",
            "    for (int id : g.data()[v]) {",
            "      const auto& [from, to, cost] = g.edges()[id];",
            "      int nxt = from ^ to ^ v;",
            "      if (d[nxt] != -1) continue;",
            "      d[nxt] = d[v] + cost;",
            "      q.emplace(nxt);",
            "    }",
            "  }",
            "  return d;",
            "}"
        ],
        "timestamp": 1632533357.224503
    },
    "diameter": {
        "prefix": "diameter",
        "body": [
            "template <class T>",
            "T diameter(const forest<T>& g) {",
            "  std::vector d1 = bfs(g, 0);",
            "  std::vector d2 =",
            "      bfs(g, std::distance(d1.begin(), std::max_element(d1.begin(), d1.end())));",
            "  return *std::max_element(d2.begin(), d2.end());",
            "}"
        ],
        "timestamp": 1632533367.232444
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class T>",
            "std::vector<T> dijkstra(const graph<T>& g, int s) {",
            "  std::vector<T> dist(g.size(), std::numeric_limits<T>::max() / 2);",
            "  using P = std::pair<T, int>;",
            "  std::priority_queue<P, std::vector<P>, std::greater<P>> pq;",
            "  dist[s] = 0;",
            "  pq.emplace(0, s);",
            "  while (!pq.empty()) {",
            "    auto [d, v] = pq.top();",
            "    pq.pop();",
            "    if (dist[v] < d) continue;",
            "    for (int id : g.data()[v]) {",
            "      const auto& [from, to, cost] = g.edges()[id];",
            "      int nxt = from ^ to ^ v;",
            "      if (dist[nxt] > dist[v] + cost) {",
            "        dist[nxt] = dist[v] + cost;",
            "        pq.emplace(dist[nxt], nxt);",
            "      }",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ],
        "timestamp": 1632533376.2864492
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "template <class T>",
            "class graph {",
            " public:",
            "  explicit graph(int n) : n_(n) { data_.resize(n); }",
            "",
            "  struct edge {",
            "    int from, to;",
            "    T cost;",
            "  };",
            "  int n_;",
            "",
            "  virtual void add(int from, int to, T cost) = 0;",
            "",
            "  int size() const { return n_; }",
            "",
            "  const std::vector<std::vector<int>>& data() const { return this->data_; }",
            "",
            "  const std::vector<edge>& edges() const { return this->edges_; }",
            "",
            " protected:",
            "  std::vector<std::vector<int>> data_;",
            "  std::vector<edge> edges_;",
            "};",
            "",
            "template <class T>",
            "class forest : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  explicit forest(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.push_back({from, to, cost});",
            "  }",
            "};",
            "",
            "template <class T>",
            "class digraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  explicit digraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    edges_.push_back({from, to, cost});",
            "  }",
            "",
            "  digraph<T> reverse() const {",
            "    digraph<T> rev(n_);",
            "    for (const auto& [from, to, cost] : edges_) {",
            "      rev.add(to, from, cost);",
            "    }",
            "    return rev;",
            "  }",
            "};",
            "",
            "template <class T>",
            "class undigraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  explicit undigraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.push_back({from, to, cost});",
            "  }",
            "};"
        ],
        "timestamp": 1632533387.5771122
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template <class T>",
            "std::vector<T> divisor(T n) {",
            "  std::vector<int> v;",
            "  for (T i = 1; i * i <= n; ++i) {",
            "    if (n % i == 0) {",
            "      v.emplace_back(i);",
            "      if (i * i != n) v.emplace_back(n / i);",
            "    }",
            "  }",
            "  std::sort(v.begin(), v.end());",
            "  return v;",
            "}"
        ],
        "timestamp": 1632533489.722888
    },
    "factor": {
        "prefix": "factor",
        "body": [
            "template <class T>",
            "std::map<T, int> factor(T n) {",
            "  std::map<T, int> m;",
            "  for (T i = 2; i * i <= n; ++i) {",
            "    if (n % i != 0) continue;",
            "    int cnt = 0;",
            "    while (n % i == 0) {",
            "      n /= i;",
            "      ++cnt;",
            "    }",
            "    m[i] = cnt;",
            "  }",
            "  if (n != 1) m[n] = 1;",
            "  return m;",
            "}"
        ],
        "timestamp": 1632533481.2808976
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "namespace miller_rabin {",
            "template <class T, class U>",
            "T power(T base, U exp, U mod) {",
            "  T res = 1;",
            "  base %= mod;",
            "  while (exp) {",
            "    if (exp & 1) (res *= base) %= mod;",
            "    (base *= base) %= mod;",
            "    exp >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "bool is_prime(int n) {",
            "  if (n < 2) return false;",
            "  int s = __builtin_ctz(n - 1);",
            "  int d = (n - 1) >> s;",
            "  for (int a : {2, 7, 61}) {",
            "    if (a % n == 0) continue;",
            "    long long cur = a;",
            "    cur = power(cur, d, n);",
            "    if (cur == 1) continue;",
            "    bool witness = true;",
            "    for (int r = 0; r < s; ++r) {",
            "      if (cur == n - 1) {",
            "        witness = false;",
            "        break;",
            "      }",
            "      (cur *= cur) %= n;",
            "    }",
            "    if (witness) return false;",
            "  }",
            "  return true;",
            "}",
            "",
            "bool is_prime(long long n) {",
            "  if (n < 2) return false;",
            "  int s = __builtin_ctzll(n - 1);",
            "  long long d = (n - 1) >> s;",
            "  for (long long a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
            "    if (a % n == 0) continue;",
            "    __int128_t cur = a;",
            "    cur = power(cur, d, n);",
            "    if (cur == 1) continue;",
            "    bool witness = true;",
            "    for (int r = 0; r < s; ++r) {",
            "      if (cur == n - 1) {",
            "        witness = false;",
            "        break;",
            "      }",
            "      (cur *= cur) %= n;",
            "    }",
            "    if (witness) return false;",
            "  }",
            "  return true;",
            "}",
            "}  // namespace miller_rabin",
            "",
            "using miller_rabin::is_prime;"
        ],
        "timestamp": 1632533470.7624142
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <class T>",
            "T inverse(T a, T m) {",
            "  T u = 0, v = 1;",
            "  while (a != 0) {",
            "    T t = m / a;",
            "    m -= t * a;",
            "    std::swap(a, m);",
            "    u -= t * v;",
            "    std::swap(u, v);",
            "  }",
            "  assert(m == 1);",
            "  return u;",
            "}",
            "",
            "template <int Mod>",
            "class Modular {",
            " public:",
            "  constexpr Modular(long long val = 0) : val_(val % mod()) {",
            "    if (val_ < 0) val_ += mod();",
            "  }",
            "",
            "  const long long& operator()() const noexcept { return val_; }",
            "",
            "  constexpr int mod() const noexcept { return Mod; }",
            "",
            "  constexpr Modular& operator+=(const Modular& other) noexcept {",
            "    if ((val_ += other.val_) >= mod()) val_ -= mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator-=(const Modular& other) noexcept {",
            "    if ((val_ -= other.val_) < 0) val_ += mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator*=(const Modular& other) noexcept {",
            "    (val_ *= other.val_) %= mod();",
            "    if (val_ < 0) val_ += mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator/=(const Modular& other) noexcept {",
            "    return *this *= Modular(inverse(other.val_, static_cast<long long>(mod())));",
            "  }",
            "",
            "  constexpr Modular& operator++() noexcept { return *this += 1; }",
            "",
            "  constexpr Modular& operator--() noexcept { return *this -= 1; }",
            "",
            "  constexpr Modular operator-() const noexcept { return Modular(-val_); }",
            "",
            "  friend std::istream& operator>>(std::istream& is, Modular& x) {",
            "    long long n;",
            "    is >> n;",
            "    x = Modular(n);",
            "    return is;",
            "  }",
            "",
            "  friend std::ostream& operator<<(std::ostream& os, const Modular& x) {",
            "    return os << x();",
            "  }",
            "",
            " private:",
            "  long long val_;",
            "};",
            "",
            "constexpr int md = int(1e9) + 7;",
            "using mint = Modular<md>;",
            "",
            "mint operator+(const mint& lhs, const mint& rhs) noexcept {",
            "  return mint(lhs) += rhs;",
            "}",
            "",
            "mint operator-(const mint& lhs, const mint& rhs) noexcept {",
            "  return mint(lhs) -= rhs;",
            "}",
            "",
            "mint operator*(const mint& lhs, const mint& rhs) noexcept {",
            "  return mint(lhs) *= rhs;",
            "}",
            "",
            "mint operator/(const mint& lhs, const mint& rhs) noexcept {",
            "  return mint(lhs) /= rhs;",
            "}",
            "",
            "bool operator==(const mint& lhs, const mint& rhs) noexcept {",
            "  return lhs() == rhs();",
            "}",
            "",
            "bool operator!=(const mint& lhs, const mint& rhs) noexcept {",
            "  return !(lhs() == rhs());",
            "}",
            "",
            "template <class T>",
            "mint power(const mint& a, T b) {",
            "  assert(b >= 0);",
            "  mint x = a, res = 1;",
            "  while (b) {",
            "    if (b & 1) res *= x;",
            "    x *= x;",
            "    b >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "// std::vector<mint> fact{1, 1};",
            "// std::vector<mint> inv{0, 1};",
            "// std::vector<mint> ifact{1, 1};",
            "",
            "// mint choose(int n, int k) noexcept {",
            "//   if (n < k || n < 0 || k < 0) return 0;",
            "//   while (int(fact.size()) < n + 1) {",
            "//     int sz = fact.size();",
            "//     fact.emplace_back(fact.back() * sz);",
            "//     inv.emplace_back(md - inv[md % sz] * (md / sz));",
            "//     ifact.emplace_back(ifact.back() * inv.back());",
            "//   }",
            "//   return fact[n] * ifact[k] * ifact[n - k];",
            "// }"
        ],
        "timestamp": 1632533458.6012669
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> sieve(int n) {",
            "  std::vector lp(n + 1, 0);",
            "  std::vector<int> p;",
            "  for (int i = 2; i <= n; ++i) {",
            "    if (lp[i] == 0) {",
            "      lp[i] = i;",
            "      p.emplace_back(i);",
            "    }",
            "    for (int j = 0; j < int(p.size()) && p[j] <= lp[i] && i * p[j] <= n; ++j) {",
            "      lp[i * p[j]] = p[j];",
            "    }",
            "  }",
            "  return p;",
            "}"
        ],
        "timestamp": 1632533445.3579717
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "template <class T, class U>",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {",
            "  return os << '(' << p.first << \", \" << p.second << ')';",
            "}",
            "",
            "template <class Tuple, std::size_t... Is>",
            "void tuple_out(std::ostream& os, const Tuple& t, std::index_sequence<Is...>) {",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(t)), ...) << \")\";",
            "}",
            "",
            "template <class... Args>",
            "std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& t) {",
            "  tuple_out(os, t, std::index_sequence_for<Args...>{});",
            "  return os;",
            "}",
            "",
            "template <class T>",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {",
            "  bool f = true;",
            "  for (auto&& e : v) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& s) {",
            "  bool f = true;",
            "  for (auto&& e : s) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& m) {",
            "  bool f = true;",
            "  for (auto&& e : m) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multiset<T, Compare>& s) {",
            "  bool f = true;",
            "  for (auto&& e : s) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multimap<T, U, Compare>& m) {",
            "  bool f = true;",
            "  for (auto&& e : m) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "#ifdef LOCAL",
            "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)",
            "#else",
            "#define debug(...) void(0)",
            "#endif",
            "",
            "void debug_out() { std::cerr << '\\n'; }",
            "",
            "template <class Head, class... Tail>",
            "void debug_out(Head&& head, Tail&&... tail) {",
            "  std::cerr << head;",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";",
            "  debug_out(std::forward<Tail>(tail)...);",
            "}"
        ],
        "timestamp": 1632533509.5137255
    },
    "exec": {
        "prefix": "exec",
        "body": [
            "std::string exec(const char* cmd) {",
            "  constexpr int sz = 1 << 7;",
            "  char buf[sz];",
            "  std::string s;",
            "  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, \"r\"), pclose);",
            "  if (!pipe) {",
            "    throw std::runtime_error(\"popen() failed!\");",
            "  }",
            "  while (fgets(buf, sz, pipe.get()) != nullptr) {",
            "    s += std::string(buf);",
            "  }",
            "  return s;",
            "}"
        ],
        "timestamp": 1632533516.75255
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "namespace fast_io {",
            "class scanner {",
            " public:",
            "  scanner() { fread(buf, 1, sz, stdin); }",
            "",
            "  template <class T>",
            "  inline scanner& operator>>(T& x) {",
            "    skip();",
            "    scan(x);",
            "    return *this;",
            "  }",
            "",
            " private:",
            "  static constexpr int sz = 1 << 19;",
            "  char buf[sz];",
            "  char* cur = buf;",
            "",
            "  inline void reload() {",
            "    int d = buf + sz - cur;",
            "    std::memcpy(buf, cur, d);",
            "    fread(buf + d, 1, sz - d, stdin);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void skip() {",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;",
            "  }",
            "",
            "  inline void scan(int& n) {",
            "    if (cur + 12 >= buf + sz) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, cur + 12, n).ptr);",
            "  }",
            "",
            "  inline void scan(long long& n) {",
            "    if (cur + 20 >= buf + sz) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, cur + 20, n).ptr);",
            "  }",
            "};",
            "",
            "class printer {",
            " public:",
            "  printer() {}",
            "",
            "  ~printer() { flush(); }",
            "",
            "  template <class T>",
            "  inline printer& operator<<(T x) {",
            "    print(x);",
            "    return *this;",
            "  }",
            "",
            "  template <class T>",
            "  inline void println(T x) {",
            "    print(x);",
            "    print('\\n');",
            "  }",
            "",
            " private:",
            "  static constexpr int sz = 1 << 19;",
            "  char buf[sz];",
            "  char* cur = buf;",
            "",
            "  void flush() {",
            "    fwrite(buf, 1, cur - buf, stdout);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void print(int n) {",
            "    if (cur + 12 >= buf + sz) flush();",
            "    cur = std::to_chars(cur, cur + 12, n).ptr;",
            "  }",
            "",
            "  inline void print(long long n) {",
            "    if (cur + 20 >= buf + sz) flush();",
            "    cur = std::to_chars(cur, cur + 20, n).ptr;",
            "  }",
            "",
            "  inline void print(std::size_t n) { print(int(n)); }",
            "",
            "  inline void print(std::ptrdiff_t n) { print(int(n)); }",
            "",
            "  inline void print(char c) {",
            "    if (cur + 1 >= buf + sz) flush();",
            "    *cur = c;",
            "    ++cur;",
            "  }",
            "",
            "  inline void print(const std::string& s) {",
            "    if (cur + s.size() >= buf + sz) flush();",
            "    std::strcpy(cur, s.data());",
            "    cur += s.size();",
            "  }",
            "",
            "  inline void print(const char* s) { print(std::string(s)); }",
            "};",
            "}  // namespace fast_io",
            "",
            "fast_io::scanner in;",
            "fast_io::printer out;"
        ],
        "timestamp": 1632533530.508556
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "__int128_t to_int128(const std::string& s) {",
            "  __int128_t n = 0;",
            "  bool neg = s[0] == '-';",
            "  for (int i = int(neg); i < int(s.size()); ++i) {",
            "    n = n * 10 + (s[i] & 0b1111);",
            "  }",
            "  return neg ? -n : n;",
            "}",
            "",
            "__int128_t to_int128(const char* c) { return to_int128(std::string(c)); }",
            "",
            "std::string to_string(const __int128_t& n) {",
            "  if (n == 0) return \"0\";",
            "  std::string s = \"\";",
            "  __int128_t t = n;",
            "  bool neg = n < 0;",
            "  if (neg) t = -t;",
            "  while (t) {",
            "    s += char(t % 10 | 0b110000);",
            "    t /= 10;",
            "  }",
            "  if (neg) s += '-';",
            "  std::reverse(s.begin(), s.end());",
            "  return s;",
            "}",
            "",
            "std::istream& operator>>(std::istream& is, __int128_t& n) {",
            "  std::string s;",
            "  is >> s;",
            "  n = to_int128(s);",
            "  return is;",
            "}",
            "",
            "std::ostream& operator<<(std::ostream& os, const __int128_t& n) {",
            "  return os << to_string(n);",
            "}"
        ],
        "timestamp": 1632533648.5090306
    },
    "lcs": {
        "prefix": "lcs",
        "body": [
            "std::string lcs(const std::string& s1, const std::string& s2) {",
            "  int n1 = s1.size(), n2 = s2.size();",
            "  std::vector dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      if (s1[i] == s2[j]) {",
            "        dp[i + 1][j + 1] = dp[i][j] + 1;",
            "      } else {",
            "        dp[i + 1][j + 1] = std::max(dp[i + 1][j], dp[i][j + 1]);",
            "      }",
            "    }",
            "  }",
            "  std::string s = \"\";",
            "  while (n1 > 0 && n2 > 0) {",
            "    if (s1[n1 - 1] == s2[n2 - 1]) {",
            "      s += s1[n1];",
            "      --n1;",
            "      --n2;",
            "    } else {",
            "      (dp[n1][n2] == dp[n1][n2 - 1]) ? --n2 : --n1;",
            "    }",
            "  }",
            "  std::reverse(s.begin(), s.end());",
            "  return s;",
            "}"
        ],
        "timestamp": 1632533716.536158
    },
    "levenshtein": {
        "prefix": "levenshtein",
        "body": [
            "int levenshtein(const std::string& s1, const std::string& s2) {",
            "  int n1 = s1.size(), n2 = s2.size();",
            "  std::vector dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      dp[i + 1][j + 1] = std::min(",
            "          {dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + int(s1[i] != s2[j])});",
            "    }",
            "  }",
            "  return dp[n1][n2];",
            "}"
        ],
        "timestamp": 1632533722.7644198
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> manacher(const std::string& s) {",
            "  int n = s.size();",
            "  std::vector<int> v(n);",
            "  int i = 0, j = 0;",
            "  while (i < n) {",
            "    while (i - j >= 0 && i + j < n && s[i - j] == s[i + j]) ++j;",
            "    v[i] = j;",
            "    int k = 1;",
            "    while (i - k >= 0 && k + v[i - k] < j) {",
            "      v[i + k] = v[i - k];",
            "      ++k;",
            "    }",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return v;",
            "}"
        ],
        "timestamp": 1632533732.067311
    },
    "next_char": {
        "prefix": "next_char",
        "body": [
            "class next_char {",
            " public:",
            "  explicit next_char(const std::string& s) {",
            "    n_ = s.size();",
            "    t_.resize(26, std::vector<int>(n_));",
            "    for (char c = 'a'; c <= 'z'; ++c) {",
            "      int p = n_;",
            "      for (int i = n_ - 1; i >= 0; --i) {",
            "        if (s[i] == c) p = i;",
            "        t_[c - 'a'][i] = p;",
            "      }",
            "    }",
            "  }",
            "",
            "  int find(int p, char c) const { return t_[c - 'a'][p]; }",
            "",
            "  bool contains(char c) const { return find(0, c) != n_; }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<std::vector<int>> t_;",
            "};"
        ],
        "timestamp": 1632533741.4518154
    },
    "split": {
        "prefix": "split",
        "body": [
            "std::vector<std::string> split(const std::string& s) {",
            "  std::vector<std::string> v;",
            "  std::string t;",
            "  for (auto&& c : s) {",
            "    if (std::isspace(c)) {",
            "      if (t.empty()) continue;",
            "      v.emplace_back(t);",
            "      t.clear();",
            "    } else {",
            "      t += c;",
            "    }",
            "  }",
            "  return v;",
            "}"
        ],
        "timestamp": 1632533756.4514196
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> z_algorithm(const std::string& s) {",
            "  int n = s.size();",
            "  std::vector<int> v(n);",
            "  v[0] = n;",
            "  int i = 1, j = 0;",
            "  while (i < n) {",
            "    while (i + j < n && s[j] == s[i + j]) ++j;",
            "    v[i] = j;",
            "    if (j == 0) {",
            "      ++i;",
            "      continue;",
            "    }",
            "    int k = 1;",
            "    while (i + k < n && k + v[k] < j) {",
            "      v[i + k] = v[k];",
            "      ++k;",
            "    }",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return v;",
            "}"
        ],
        "timestamp": 1632533747.9607117
    }
}