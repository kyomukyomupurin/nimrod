# Miller-Rabin primality test - ミラー・ラビン素数判定法

## About

ミラー・ラビン素数判定法は、与えられた自然数が素数かどうかを判定する確率的アルゴリズムです。計算量は、与えられる自然数を $N$ とすると $\mathcal{O}(\log N)$ です（たぶん......）

## Description

フェルマーの小定理を利用します。

素数 $p$ と、$p$ と互いに素な自然数 $a$ に対して次の式が成立する。

$a^{p-1}\equiv 1\mod p$

$p$ が合成数のときは、上記の式は一般的には成立しません（$a$ の選び方によっては、たまたま成立することもあります）。

### フェルマーテスト

素数かどうか判定したい自然数を $N$ とします。

$2\le a\le N-2$ なる $a$ を乱択し、以下の式が成立するかどうかチェックすることを繰り返します。このアルゴリズムは、フェルマーテストと呼ばれています。

$a^{N-1}\equiv 1\mod N$

もし成立しなければ、$N$ は素数ではないことがわかります。上記の式が成立しないときの $a$ は、$p$ が合成数であることの *Fermat witness* と呼ばれています。

逆に、合成数であっても、フェルマーテストをパスすることはあり得ます。このような $a$ は *Fermat liar* と呼ばれています。

とても不都合なことに、$2\le a\le N-2$ なるすべての $a$ に対してフェルマーテストをパスするような自然数が存在します。このよう自然数は *Carmichael numbers* と呼ばれ、例えば$1729$ はその 1 つです。

### ミラー・ラビン素数判定法

ミラー・ラビン素数判定法は、フェルマーテストを拡張したものです。

素数かどうか判定したい自然数を $N$ とします。さらに、ここでは $N$ は奇数とします（偶数については、自明なので）。

このとき $N-1$ は偶数となるので、以下のような式で表すことができます（$d$ は奇数）。

$N-1=2^sd$

これをフェルマーの小定理の式に代入し、変形します。

$
\begin{equation}
\begin{split}
a^{n-1}=1 \pmod n &\iff a^{2^sd}-1\\
&\iff (a^{2^{s-1}d}+1)(a^{2^{s-1}d}-1)\equiv0 \pmod n\\
&\iff (a^{2^{s-1}d}+1)(a^{2^{s-2}d}+1)(a^{2^{s-2}d}-1)\equiv0 \pmod n\\
&\iff (a^{2^{s-1}d}+1)(a^{2^{s-2}d}+1)(a^{2^{s-3}d}+1)\cdots (a^{2^2d}+1)(a^{2^1d}+1)(a^d+1)(a^d-1)\equiv0 \pmod n
\end{split}
\end{equation}
$

さらに、以下の事実を利用します。

$x^2\equiv 1\mod p$（$p$ は素数）のとき、$x\equiv 1$ または $x\equiv -1$ が成立する。

以上を踏まえると、次の 2 つの条件のうちいずれかが成立する必要があります。

- $a^d\equiv1 \pmod N$
- ある $r$（$0\le r \le s-1$）に対して $a^{2^rd}\equiv-1 \pmod N$

フェルマーテストのときと同様に、 $a$ を乱択しながら上記の条件を満たすかどうかチェックしていきます。フェルマーテストのときと同様に、上記の条件を満たしてしまうような合成数は存在し、*strong liar* と呼ばれています。しかし、幸運なことに、*Carmichael numbers* のようにすべてのチェックをパスしてしまうような合成数は存在しません。つまり、$2\le a\le N-2$ なるすべての $a$ に対して上記の条件をチェックすることで、確実な素数判定が可能です。

とはいえ、$2\le a\le N-2$ なるすべての $a$ に対してチェックを行っていたのでは、単純な試し割りと比較しても計算量が悪化しており、話になりません。ミラー・ラビン素数判定法では、*strong liar* になるような自然数の割合は最悪でも $\frac{1}{4}$ で抑えられる、という性質を利用して、得られた結果が正しい可能性を保証することができます。つまり、1 回のチェックでは、 $\frac{1}{4}$ の確率で「本当は $N$ は合成数なのに素数だと判定」してしまいます。よって、$k$ 回のチェックをパスした自然数が本当は合成数である確率は $\frac{1}{4^k}$ となります。例えば $k=20$ とすれば、誤った結果を得てしまう確率は 1 兆分の 1 以下となり、用途によってはこれは十分な精度でしょう。

ところで、[すごい人たちの努力](https://miller-rabin.appspot.com/)によって、32bit 整数 の範囲であれば 2, 7, 61 の 3 つ、64bit 整数の範囲であれば 2, 325, 9375, 28178, 450775, 9780504, 1795265022 の 7 つについてチェックを行うことで決定的に素数判定を行えることが知られています。